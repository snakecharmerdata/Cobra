Title: Build a Cobra-like Architecture Mapper (Desktop GUI + PostgreSQL)

Create a single-file Python desktop application that allows users to visually design and persist a functional architecture as draggable “function pills” on a grid canvas. Use Tkinter for the UI. Provide a responsive canvas with light grey grid lines (minor ~25px, major ~100px). Each function pill is a rounded rectangle or rectangle rendered with a name label; it can be dragged to reposition, and a status bar displays live coordinates while dragging. Double-clicking a pill opens a details dialog.

In the details dialog, allow editing the function’s Name, a multi-line Description, a multi-line Visual Output field, and a multi-line Relationships field. Include two listboxes with Add/Edit/Delete controls for Inputs and Outputs. Add a “Select Relationships” helper dialog: fetch the list of functions in the current project from the database, exclude the current function, present checkbox-style multi-select, and a multi-line Explanation text box. On save, write a compact string into the Relationships field like: “Related to: A, B, C\nExplanation: …”.

Provide a top menu bar with File options: Create New Project, Open Project, Cancel Project, Connect to Database, Save Project, Save to JSON File, Load from JSON File, and Exit. In the toolbar, expose quick actions: Add Function (prompts for the name and drops the pill centered), Clear All (with confirmation), Flow Output, Compile, Logical Mapping, and Instructions. If some features (Flow Output, Logical Mapping, Instructions) are stubs, show an informational dialog; ensure Compile gathers all functions and their metadata to produce a consolidated textual prompt or summary suitable for a generative model (may be shown in a dialog).

Persist data in PostgreSQL. On startup, attempt an automatic connection to a local server (host=localhost, port=5432) using database name Cobra and user postgres with empty password. If the target database does not exist, automatically create it by connecting to the default postgres database and issuing CREATE DATABASE. Provide a “Connect to Database” dialog to override host, port, database, user, and password, and remember the last successful connection (sans password) for convenience. Always show message dialogs for success/failure and update a status bar accordingly.

Model projects centrally and segregate per-project content by schema. Maintain a public projects table (id, name, created_at, updated_at) with a unique index on name to allow ON CONFLICT upsert. For each project name, derive a safe schema identifier like proj_<slug_of_name>, limited to 63 chars, and create it on demand. In each project schema, create tables: functions (id, name unique, description, visual_output, relationships, x_position, y_position, created_at, updated_at), function_inputs (id, function_id FK references functions(id) ON DELETE CASCADE, name, position), and function_outputs (same shape as inputs). Provide helpers that ensure these tables and the schema exist prior to reads/writes.

Implement full project workflows: Create New Project (insert into projects and ensure project schema), Open Project (list projects, including a tree or list with columns: name, function count, created, updated; double-click to open), Save Project (clear functions in the project schema then insert the current canvas state; preserve function_id references on pills post-insert), Cancel Project (show an in-memory list of recent/active project names from the session; if a selected project is not in DB, offer to remove it from the in-memory list; if present in DB, confirm and delete the project and its schema), Delete Project (permanent removal). Ensure robust error handling with transaction rollback and user-facing error dialogs on failure.

In the details dialog, include buttons for Save (apply changes to the pill and close), and a Database Operations group: Save to DB (insert/upsert a single function by name in the current project schema and insert inputs/outputs), Update in DB (update by id, replacing inputs/outputs), Delete from DB (remove this function and cascade its I/O), and Load from DB (open a list of functions in the current project and load one into the dialog fields and the pill). If there is no active project or no DB connection, prompt the user accordingly. When saving or loading from DB, synchronize the in-memory pill’s function_id.

Rendering/UX requirements: draw grid lines on canvas resize; keep dragging smooth; keep pill text centered; display live status messages (e.g., “Moving ‘X’ to (x, y)”, “Saved project ‘Y’”); ensure Clear All removes all pills from the canvas and memory after user confirmation. Support optional branding: if a cobraimage.jpeg is present and Pillow (PIL) is available, load and thumbnail it for a small logo in the toolbar and use it as the window icon; otherwise show a simple text label fallback. The app should run on macOS and Windows with only the standard library, psycopg2, and Pillow (optional) as dependencies.

Implementation constraints: ship the app as a single Python file using Tkinter. Use psycopg2 for PostgreSQL operations and parameterized SQL. Use ON CONFLICT for upserts where applicable and unique indexes to enforce uniqueness. Always guard DB operations with try/except, rollback on error, and surface user-friendly messages. For JSON import/export, write a file containing the project name and an array of function objects with all editable fields plus coordinates. Keep the UI responsive and avoid blocking the main loop with long operations.

Acceptance criteria: a user can 1) connect or auto-connect to PostgreSQL with auto-create of the target DB, 2) create a project and see its schema created, 3) add multiple draggable function pills, edit their details (including inputs/outputs/relationships via selector), and see changes reflected on the canvas, 4) save the entire design to the project schema or JSON, 5) load an existing project from DB or JSON into the canvas, 6) save/update/delete a single function from its detail dialog, 7) open a project list with counts and timestamps, and 8) delete/cancel projects with confirmations and consistent UI updates.